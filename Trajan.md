## 초록

최근 다양한 블록체인 플랫폼이 나오고 있는 가운데 탈중앙성을 위한 낮은 TPS와 긴 블록타임 등은 사용자들에게 불편을 주고 탈중앙 어플리케이션들의 상용화를 방해하는 요인이 되고 있다. 이를 극복하기 위해 사이드체인과 샤딩 등 다중 블록체인 솔루션이 제안되었다. 이 글에서는 그 중 플라즈마 방식을 활용하여 단일 운영자에 의한 빠른 속도를 제공하며 동시에 이더리움 블록체인에 의해 신용이 담보되는 스케일링 솔루션을 제안한다.

## 트라얀을 위한 Fraud Proof 

Fraud proof는 트라얀의 블록 생성자가 잘못된 블록을 생성하였을 때(곧, 서명이 잘못된 트랜잭션을 포함시키거나, 트랜잭션에 명시된 대로의 상태 변환을 실행하지 않거나, 등등) 이를 최종 검증하는 이더리움 상의 컨트랙이 해당 상태 변환을 잘못되었다는 것을 알 수 있도록 하는 방법이다. Fraud Proof는 모든 트랜잭션이 변경 불가능한 네트워크(IPFS등)에 공개되었을 때에만 유효하다. 블록 생성자가 실수로 또는 의도적으로 모든 트랜잭션을 공표하지 않았을 때 적절한 fraud proof를 생성하지 못하는 문제를 data availability problem이라 하며, 이는 트라얀 토큰 이코노미를 통해 해결된다.

https://eprint.iacr.org/2016/683.pdf
https://github.com/ethereum/wiki/wiki/%5BKorean%5D-White-Paper#%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9C%BC%EB%A1%9C%EC%84%9C%EC%9D%98-%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8bitcoin-as-a-state-transition-system

Fraud proof는 머클 증명의 결합으로 이루어진다. 머클 증명은 하나의 값이 특정한 값을 루트로 가지는 머클 트리에 존재한다는 것을 O(log n)의 복잡도로 증명할 수 있게 해 준다. 만약 머클 트리의 값들이 정렬되어 트리를 이루고 있다면, 이는 보다 특수한 종류의 머클 트리인 Sparse 머클 트리를 만들게 되며, 특정 값의 비존재를 효율적으로 증명할 수 있도록 한다. 우리는 이 두가지 방식을 결합하여 머클 '상태변환' 증명을 구성할 수 있다. 

블록체인은 하나의 상태 변환 기계로 이해할 수 있다. 상태는 하나의 머클 트리를 구성하며, 트랜잭션은 상태 변환 함수로서 그 상태를 이루는 값들을 바꾼다. 머클 트리의 루트는 트리를 이루는 모든 값에 의존적이기 때문에, 트랜잭션에 의한 상태 변환은 루트의 값을 변화시키게 된다. 

머클 '상태변환' 증명은 크게 두 종류로 구분할 수 있다: 값이 추가되는 경우와 값이 수정되는 경우.

### 머클 트리

머클 증명은 특정 원소가 트리를 구성한다는 것을 효율적으로 증명한다. 머클 증명은 인접한 다른 원소들의 값에 의해 결정되기 때문에, 원소의 위치가 바뀌지 않는 이상 그 원소가 아무리 많이 수정되더라도 여전히 같은 증명을 새로운 머클 루트에 대해 사용할 수 있다는걸 명심하라(단, 다른 원소들이 추가되거나 수정되지 않았다는 가정 하에). 

(TODO: 설명 생략)

존재 증명을 통해 효과적으로 새로운 값이 추가되는 경우를 가정하기 위해 정렬된 머클 트리를 사용한다. 각 원소는 키와 밸류 두 값을 포함하는 바이트 배열 쌍으로 이루어져 있다. 그들의 말단 해시값은 여전히 전체 값(키와 배열을 어떠한 형태로 합친)으로 구성되어 있지만, 그들이 정렬되는 방식은 오직 키 값에 의존한다. 키 값은 밸류 값에 의존하지 아니하여야 한다. 이는 밸류 값이 바뀌더라도 머클 트리 내에서 키-밸류 쌍의 위치는 유지되도록 한다.

이는 우리가 사용할 머클 트리가 다음의 세 조건을 충족한다는 것을 뜻한다.

1. 머클 트리를 구성하는 모든 원소에 대해, 이를 검증하는 머클 증명이 존재한다.
2. 머클 트리를 구성하는 원소의 밸류가 바뀌어도, 머클 증명의 유효성은 변경되지 않는다.
3. 머클 트리를 구성하지 않는 모든 원소에 대해, 이를 검증하는 머클 증명이 존재한다.

논의의 편의를 위해, 하나의 트랜잭션은 머클 트리를 구성하는 원소 중 단 하나의 원소 밸류만 변경한다고 가정한다. 

=> 각 tx는 상태를 받아 상태를 돌려주는 함수이고 단 하나의 값만 변경한다고 가정한다(여러 상태를 변경하는 트랜잭션은 하나의 값만 변경하는 트랜잭션들의 합성으로 모사할 수 있기 때문이다)

### 머클 값 수정 상태변환 증명 

어떠한 트랜잭션이 한 원소의 밸류를 수정하는 경우를 가정하라. 해당 트랜잭션의 작동 방식은 알려져 있다. 만약 트랜잭션 실행 이전의 상태에 해당 원소가 존재한다면 머클 증명은 상태 변환 이후에도 유효할 것이다. 머클 증명이 이전 상태에서는 유효하나 이후 상태에서는 유효하지 않다면, 이는 주어진 이후 상태의 머클 루트 값이 잘못 계산되었다는 것을 뜻한다.

트랜잭션 t가 원소 (k, v)를 포함하는 머클 루트 r에 적용되었을 때 이를 원소 (k, v')를 포함하는 머클 루트 r' 로 변화시킨다고 하자. 이때 머클 증명 p가 ((k, v), r)에 대해 참으로 평가된다면, 이는 ((k, v'), r')에 대해서도 참으로 평가되어야 한다. 컨트랙은 주어진 머클 루트가 올바른 상태 변환을 통해 유도된 것인지를 이 방법을 통해 검증할 수 있다.


let S' = tx(S)
where (elems, root) = S and (elems', root') = S'

=> tx가 S상에서 실행되었을 때의 결과 상태를 S'라고 하자

assume (k, v) is member of elems, (k, v') is memeber of elems'
therefore there exists proof that satisfies exists(proof, k, v, root) and exists(proof, k, v', root')

=> 특정한 키값에 대해 밸류가 상태 변환으로 인해 바뀌었다면, 같은 증명을 사용하여 이후 상태값에 바뀐 밸류가 포함된다는 것을 증명 가능하다.

given tx, root, root', k, v, v' and proof, if exists(proof, k, v, root) but !exists(proof, k, v', root'), root' is not valid merkle root of tx(S)

=> 따라서 트랜잭션, 이전 이후 루트값, 키값, 전후 밸류값, 증명이 주어졌을 때, 이전 루트에 머클 증명이 작동하나 이후 루트에는 적용이 안된다면, 이는 주어진 이후 루트값이 올바르지 않다는 증명이다.

### 머클 값 추가 상태변환 증명

어떠한 트랜잭션이 이전에 없었던 한 원소를 추가하는 경우를 가정하라. 이때, 상태 변환 이후의 머클 트리에 대해서는 값이 올바른 위치에 추가되었다는 것을 검증하는 것이 필요하며 상태 변환 이전에 대해서는 값이 존재하지 않았다는 것을 증명해야 한다.

트랜잭션 t가 원소 (k, v)를 포함하지 않는 머클 루트 r에 적용되었을 때 

let S' = tx(S)
wherer (elems, root) = S and (elems', root') = S'

assume (k, v) is not a member of elems, but of elems'

=> 이전 상태값에는 해당 키밸류 쌍이 없었는데 이후 상태에 추가된 경우를 생각해보자.

therefore there exists proof that absent(proof, k, v, root) = true and there exists proof' that exists(proof', k, v, root')

=> 이전 상태에는 k와 v가 원소로 포함되어있지 않다는 비존재 증명이 존재하고, 이후 상태에는 k와 v가 원소로 포함되어 있다는 존재 증명이 존재한다.

given tx, root, root', k, v, proof and proof', if absent(proof, k, v, root) 

## 토큰 이코노미
